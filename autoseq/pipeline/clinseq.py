from pypedream.pipeline.pypedreampipeline import PypedreamPipeline
from autoseq.util.path import normpath, stripsuffix
from autoseq.tools.alignment import align_library, Realignment
from autoseq.tools.cnvcalling import Cns2Seg, CNVkit, CNVkitFix, QDNASeq
from autoseq.tools.purity import PureCN
from autoseq.tools.igv import MakeAllelicFractionTrack, MakeCNVkitTracks, MakeQDNAseqTracks
from autoseq.util.library import find_fastqs
from autoseq.tools.picard import PicardCollectInsertSizeMetrics, PicardCollectOxoGMetrics, \
    PicardMergeSamFiles, PicardMarkDuplicates, PicardCollectHsMetrics, PicardCollectWgsMetrics
from autoseq.tools.variantcalling import HaplotypeCaller, VEP, VcfAddSample, VarDictForPureCN, \
    call_somatic_variants, StrelkaGermline, SomaticSeq , MergeVCF, GenerateIGVNavInput
from autoseq.tools.msi import MsiSensor, Msings
from autoseq.tools.contamination import ContEst, ContEstToContamCaveat, CreateContestVCFs
from autoseq.tools.qc import *
from autoseq.util.clinseq_barcode import *
import collections, logging


class InvalidRefDataException(Exception):
    """Custom exception indicating that the genome reference data is not valid
    in the context of the current pipeline configuration."""
    pass


class SinglePanelResults(object):
    """
    Represents the results generated by performing analysis on a unique sample library capture,
    irrespective of the sample type.

    For Liqbio pipeline: UMI processed bamfile variable added to this object.
    """
    def __init__(self):
        self.merged_bamfile = None
        self.umi_bamfile = None

        # CNV kit outputs:
        self.cnr = None
        self.cns = None
        self.seg = None

        # Coverage QC call:
        self.cov_qc_call = None

        # Structural variants, organised as a dictionary with event type as key,
        # and their effects:
        self.svs = {}
        self.sv_effects = None

        # FIXME: Msings should never be run for normal samples => OO progr. fail. Refactor.
        # Msings output:
        self.msings_output = None


class CancerVsNormalPanelResults(object):
    """
    Represents the results generated by performing a paired analysis comparing a cancer and a normal capture.
    """
    def __init__(self):
        self.somatic_vcf = None
        self.vepped_vcf = None
        self.msi_output = None
        self.hzconcordance_output = None
        self.vcf_addsample_output = None
        self.normal_contest_output = None
        self.cancer_contest_output = None
        self.cancer_contam_call = None
        self.pureCN_outputs = None


class ClinseqPipeline(PypedreamPipeline):
    """
    A pipeline for processing clinseq cancer genomics.
    """
    def __init__(self, sampledata, refdata, job_params, outdir, libdir, umi, maxcores=1, 
                 scratch="/scratch/tmp/tmp", analysis_id=None, **kwargs):
        """
        :param sampledata: A dictionary specifying the clinseq barcodes of samples of different types.
        :param refdata: A dictionary specifying the reference data used for configuring the pipeline jobs.
        :param outdir: Output folder location string.
        :param libdir: String specifying location of the library fastq files.
        :param maxcores: Maximum number of cores to use concurrently in this analysis.
        :param scratch: String indicating folder in which jobs should output all temporary files.
        :param kwargs: Additional key-word arguments.
        :param umi: Flag which can be used for umi-liqbio pipeline.
        """
        PypedreamPipeline.__init__(self, normpath(outdir), **kwargs)
        self.sampledata = sampledata
        self.refdata = refdata
        # FIXME: Introduced a simple dictionary for configuring various pipeline job parameters.
        # However, this solution is still not elegant:
        self.job_params = job_params
        self.maxcores = maxcores
        self.libdir = libdir
        self.qc_files = []
        self.scratch = scratch
        self.analysis_id = analysis_id
        self.umi = umi

        # Set up default job parameters:
        self.default_job_params = {
            "cov-high-thresh-fraction": 0.95,
            "cov-high-thresh-fold-cov": 100,
            "cov-low-thresh-fraction": 0.95,
            "cov-low-thresh-fold-cov": 50,
            "vardict-min-alt-frac": 0.02,
            "vardict-min-num-reads": None,
            "vep-additional-options": "",
            "maxnonclonal_purecn": 0.2
        }

        # Dictionary linking unique captures to corresponding generic single panel
        # analysis results (SinglePanelResults objects as values):
        self.capture_to_results = collections.defaultdict(SinglePanelResults)

        # Dictionary linking unique normal library capture items to their corresponding
        # germline VCF filenames:
        self.normal_capture_to_vcf = {}

        # Dictionary linking (normal capture, cancer capture) pairings to corresponding
        # cancer library capture analysis results (CancerPanelResults objects as values):
        self.normal_cancer_pair_to_results = collections.defaultdict(CancerVsNormalPanelResults)

    def get_job_param(self, param_name):
        """
        Retrieve the parameter of the specified name from the job parameters, or
        return a default value if it is not found.

        :param param_name: String defining the parameter to retrieve 
        :return: The parameter value to use.
        """

        if param_name in self.job_params.keys():
            return self.job_params[param_name]
        else:
            return self.default_job_params[param_name]

    def set_germline_vcf(self, normal_capture, vcfs):
        """
        Registers the specified vcf filename for the specified normal capture item,
        for this analysis.

        :param normal_capture: Normal panel capture identifier.
        :param vcfs: Tuple specifying (germline_variants_vcf, vepped_germline_variants_vcf)
        """

        self.normal_capture_to_vcf[normal_capture] = vcfs

    def get_germline_vcf(self, normal_capture):
        """
        Obtain the germline VCF (original, un-vepped) for the given normal sample capture item.

        :param normal_capture: Named tuple indicating a unique library capture.
        :return: Original (un-vepped) germline VCF if available, otherwise None.
        """
        if normal_capture in self.normal_capture_to_vcf:
            return self.normal_capture_to_vcf[normal_capture][0]
        else:
            return None

    def get_vepped_germline_vcf(self, normal_capture):
        """
        Obtain the VEPped germline VCFs (original) for the given normal sample capture item.

        :param normal_capture: Named tuple indicating a unique library capture.
        :return: VEPped germline VCF if available, otherwise None.
        """
        if normal_capture in self.normal_capture_to_vcf:
            return self.normal_capture_to_vcf[normal_capture][1]
        else:
            return None

    def set_capture_bam(self, unique_capture, bam, umi):
        """
        Set the bam file corresponding to the specified unique_capture in this analysis.

        :param unique_capture: A UniqueCapture item. 
        :param bam: The bam filename.
        """
        if umi:
            self.capture_to_results[unique_capture].umi_bamfile = bam
        else:
            self.capture_to_results[unique_capture].merged_bamfile = bam

    def set_capture_sveffect(self, unique_capture, effects_json):
        """
        Record the structural variants effect prediction.

        :param unique_capture: Named tuple indicating unique library capture.
        :param effects_json: String indicating JSON file of predicted effects
        """

        self.capture_to_results[unique_capture].sv_effects = effects_json

    def set_capture_svs(self, unique_capture, event_type, svs_tup):
        """
        Record the structural variants results for the given library capture and event type.

        :param unique_capture: Named tuple indicating unique library capture.
        :param event_type: String indicating structural variant event type
        :param svs_tup: Tuple containing (bam_filename, gtf_filename)
        """

        # FIXME: This approach is become unwieldy.
        self.capture_to_results[unique_capture].svs[event_type] = svs_tup

    def set_capture_cnr(self, unique_capture, cnr):
        """
        Record the CNR copy number information (CNV kit output) for the given library capture.

        :param unique_capture: Named tuple indicating unique library capture.
        :param cnr: CNR output filename.
        """
        self.capture_to_results[unique_capture].cnr = cnr 

    def set_capture_cns(self, unique_capture, cns):
        """
        Record the CNS copy number information (CNV kit output) for the given library capture.

        :param unique_capture: Named tuple indicating unique library capture.
        :param cnr: CNS output filename.
        """
        self.capture_to_results[unique_capture].cns = cns

    def set_capture_seg(self, unique_capture, seg):
        """
        Record the seg file (converted CNV kit output) for the given library capture.

        :param unique_capture: Named tuple indicating unique library capture.
        :param cnr: CNS output filename.
        """
        self.capture_to_results[unique_capture].seg = seg

    def get_capture_bam(self, unique_capture, umi):
        """
        Retrieve the bam file corresponding to the specified unique_capture in this analysis.

        :param unique_capture: Named tuple indicating unique library capture.
        :return: The corresponding bam filename, or None if it has not been configured.
        """

        if unique_capture in self.get_mapped_captures_all():
            if umi:
                return self.capture_to_results[unique_capture].umi_bamfile
            else:
                return self.capture_to_results[unique_capture].merged_bamfile           
        else:
            return None

    def check_sampledata(self):
        """
        Check this pipeline for validity of the sample data. In particular, check that
        each clinseq barcode has a corresponding fastq file, and if not, then modify
        the pipeline's sampledata by removing that clinseq barcode from the analysis.
        """

        for sample_type in ['N', 'T', 'CFDNA']:
            clinseq_barcodes_with_data = []
            for clinseq_barcode in self.sampledata[sample_type]:
                if data_available_for_clinseq_barcode(self.libdir, clinseq_barcode):
                    clinseq_barcodes_with_data.append(clinseq_barcode)

            self.sampledata[sample_type] = clinseq_barcodes_with_data

    def vep_data_is_available(self):
        """
        Indicates whether the VEP folder has been set for this analysis.

        :return: Boolean.
        """
        return self.refdata['vep_dir'] != None

    def get_mapped_captures_all(self):
        """
        Obtain all unique sample library captures in this pipeline instance (including
        library -> WGS items).

        :return: List of unique capture named tuples. 
        """

        return self.capture_to_results.keys()

    def get_mapped_captures_no_wgs(self):
        """
        Obtain all unique sample library captures in this pipeline instance (excluding
        library -> WGS items).

        :return: List of unique capture named tuples.
        """
        
        return [capture for capture in self.capture_to_results.keys()
                if capture.capture_kit_id != "WG"]

    def get_mapped_captures_only_wgs(self):
        """
        Obtain all unique sample library captures in this pipeline instance (only
        including library -> WGS items).

        :return: List of unique capture named tuples.
        """

        return [capture for capture in self.capture_to_results.keys()
                if capture.capture_kit_id == "WG"]

    def get_mapped_captures_normal(self):
        """
        Obtain tuples for all unique normal sample library captures
        in this pipeline instance - not including "WGS" (no) capture items.

        :return: List of named tuples.
        """

        non_wgs_unique_captures = self.get_mapped_captures_no_wgs()
        return filter(lambda unique_capture: unique_capture.sample_type == "N",
                      non_wgs_unique_captures)

    def get_mapped_captures_cancer(self):
        """
        Obtain all unique cancer sample library captures items in this
        pipeline instance - not including "WGS" (no) capture items.

        :return: List of named tuples.
        """
    
        non_wgs_unique_captures = self.get_mapped_captures_no_wgs()
        return filter(lambda unique_capture: unique_capture.sample_type != "N",
                      non_wgs_unique_captures)

    def get_prep_kit_name(self, prep_kit_code):
        """
        Convert a two-letter library kit code to the corresponding library kit name.

        :param prep_kit_code: Two-letter library prep code. 
        :return: The library prep kit name.
        """

        # FIXME: Move this information to a config JSON file.
        prep_kit_lookup = {"BN": "BIOO_NEXTFLEX",
                           "KH": "KAPA_HYPERPREP",
                           "TD": "THRUPLEX_DNASEQ",
                           "TP": "THRUPLEX_PLASMASEQ",
                           "TF": "THRUPLEX_FD",
                           "TS": "TRUSEQ_RNA",
                           "NN": "NEBNEXT_RNA",
                           "VI": "VILO_RNA"}

        return prep_kit_lookup[prep_kit_code]

    def get_capture_name(self, capture_kit_code):
        """
        Convert a two-letter capture kit code to the corresponding capture kit name.

        :param capture_kit_code: The two-letter capture kit code.
        :return: The capture-kit name.
        """
        
        # FIXME: Move this information to a config JSON file.
        capture_kit_loopkup = {"CS": "clinseq_v3_targets",
                               "CZ": "clinseq_v4",
                               "EX": "EXOMEV3",
                               "EO": "EXOMEV1",
                               "RF": "fusion_v1",
                               "CC": "core_design",
                               "CD": "discovery_coho",
                               "CB": "big_design",
                               "AL": "alascca_targets",
                               "TT": "test-regions",
                               "CP": "progression",
                               "CM": "monitor",
                               "PC": "probio_comprehensive",
                               "PB": "probio_biomarker_signature",
                               "PA": "pancancer",
                               "C2": "probio_comprehensive2",
                               "PN": "pancancer2"
                               }

        if capture_kit_code == 'WG':
            return 'lowpass_wgs'

        else:
            return capture_kit_loopkup[capture_kit_code]

    def get_all_clinseq_barcodes(self):
        """
        :return: All clinseq barcodes included in this clinseq analysis pipeline's panel data.
        """

        all_clinseq_barcodes = \
            self.sampledata['T'] + \
            self.sampledata['N'] + \
            self.sampledata['CFDNA']
        return filter(lambda bc: bc != None, all_clinseq_barcodes)

    def get_unique_capture_to_clinseq_barcodes(self):
        """
        Retrieves all clinseq barcodes for this clinseq analysis, and organises them according
        to unique library captures.

        :return: A dictionary with tuples indicating unique library captures as keys,
        and barcode lists as values.
        """

        capture_to_barcodes = collections.defaultdict(list)
        for clinseq_barcode in self.get_all_clinseq_barcodes():
            unique_capture = extract_unique_capture(clinseq_barcode)
            capture_to_barcodes[unique_capture].append(clinseq_barcode)

        return capture_to_barcodes

    def merge_and_rm_dup(self, unique_capture, input_bams):
        """
        Configures Picard merging and duplicate marking, for the specified group input bams,
        which should all correspond to the specified sample library capture.

        Registers the final output bam file for this library capture in this analysis.

        :param unique_capture: A unique library capture specification
        :param input_bams: The bam filenames for which to do merging and duplicate marking
        """

        # Strings indicating the sample and capture, for use in output file names below:
        capture_str = compose_lib_capture_str(unique_capture)
        targets = self.get_capture_name(unique_capture.capture_kit_id)
        #sample_str = "{}-{}".format(unique_capture.sample_type, unique_capture.sample_id)
        #capture_str = "{}-{}-{}".format(sample_str, unique_capture.library_kit_id, unique_capture.capture_kit_id)

        # Configure merging:
        merged_bam_filename = \
            "{}/bams/{}/{}.bam".format(self.outdir, unique_capture.capture_kit_id, capture_str)
        merge_bams = PicardMergeSamFiles(input_bams, merged_bam_filename)
        merge_bams.is_intermediate = True
        merge_bams.jobname = "picard-mergebams-{}".format(capture_str)
        self.add(merge_bams)

        # Configure Realignment:
        realignment = Realignment()
        realignment.input_bam = merge_bams.output_bam
        realignment.scratch = self.scratch
        realignment.output_bam = "{}/bams/{}/{}-realigned.bam".format(self.outdir, unique_capture.capture_kit_id, capture_str)
        realignment.target_intervals = "{}/bams/{}/{}.intervals".format(self.outdir, unique_capture.capture_kit_id, capture_str)
        realignment.reference_genome = self.refdata['reference_genome']
        realignment.target_region = self.refdata['targets'][targets]['targets-bed-slopped20']
        realignment.known_indel1 = self.refdata["1KG"]
        realignment.known_indel2 = self.refdata["Mills_and_1KG_gold_standard"]
        self.add(realignment)

        # Configure duplicate marking:
        self.configure_markdups(realignment.output_bam , unique_capture)
        
    def configure_markdups(self, bamfile, unique_capture):

        capture_str = compose_lib_capture_str(unique_capture)

        mark_dups_bam_filename = \
            "{}/bams/{}/{}-nodups.bam".format(self.outdir, unique_capture.capture_kit_id, capture_str)
        mark_dups_metrics_filename = \
            "{}/qc/picard/{}/{}-markdups-metrics.txt".format(
                self.outdir, unique_capture.capture_kit_id, capture_str)
        markdups = PicardMarkDuplicates(
            bamfile, mark_dups_bam_filename, mark_dups_metrics_filename)
        markdups.is_intermediate = False
        self.add(markdups)

        # FIXME: Continue here: Need to fix naming of bam files and naming of the
        # sample in the bam header. Currently not sure how/where to fix this, and merge_bams.output_bam
        # seems to not exist.

        #umi is set False as default - Markdups is only applicable for Non-Umi files

        self.set_capture_bam(unique_capture, markdups.output_bam, umi=False)

        self.qc_files.append(markdups.output_metrics)

    def configure_fastq_qcs(self):
        """
        Configure QC on all fastq files that exist for this pipeline instance.

        :return: List of qc output filenames.
        """

        for clinseq_barcode in self.get_all_clinseq_barcodes():
            curr_fqs = reduce(lambda l1, l2: l1 + l2,
                              find_fastqs(clinseq_barcode, self.libdir))
            for fq in curr_fqs:
                fastqc = FastQC()
                fastqc.input = fq
                fastqc.outdir = "{}/qc/fastqc/".format(self.outdir)
                fastqc.output = "{}/qc/fastqc/{}_fastqc.zip".format(
                    self.outdir, clinseq_barcode)
                fastqc.jobname = "fastqc-{}".format(clinseq_barcode)
                self.qc_files.append(fastqc.output)
                self.add(fastqc)

    def configure_align_and_merge(self):
        """
        Configure the aligning of the fastq files for all clinseq barcodes in this pipeline,
        and configure merging of the resulting bam files organised according to unique
        sample library captures (including "WGS" captures - i.e. no capture).
        """

        capture_to_barcodes = self.get_unique_capture_to_clinseq_barcodes()
        for unique_capture in capture_to_barcodes.keys():
            curr_bamfiles = []
            capture_kit = unique_capture.capture_kit_id
            for clinseq_barcode in capture_to_barcodes[unique_capture]:
                curr_bamfiles.append(
                    align_library(self,
                                  fq1_files=find_fastqs(clinseq_barcode, self.libdir)[0],
                                  fq2_files=find_fastqs(clinseq_barcode, self.libdir)[1],
                                  clinseq_barcode=clinseq_barcode,
                                  ref=self.refdata['bwaIndex'],
                                  outdir= "{}/bams/{}".format(self.outdir, capture_kit),
                                  maxcores=self.maxcores,
                                  remove_duplicates=True))

            self.merge_and_rm_dup(unique_capture, curr_bamfiles)

    def call_germline_variants(self, normal_capture, bam):
        """
        Configure calling of germline variants for a normal sample library capture,
        and configure VEP if specified in the analysis.
        Haplotypecaller and Strelka germline variant callers added in latest version

        :param normal_capture: The normal sample library capture identifier.
        :param bam: Bam filename input to variant calling.
        """

        targets = self.get_capture_name(normal_capture.capture_kit_id)
        capture_str = compose_lib_capture_str(normal_capture)

        haplotypecaller = HaplotypeCaller()
        haplotypecaller.input_bam = bam
        haplotypecaller.reference_sequence = self.refdata['reference_genome']
        haplotypecaller.interval_list = self.refdata['targets'][targets]['targets-interval_list-slopped20']
        haplotypecaller.dbSNP = self.refdata['dbSNP']
        haplotypecaller.output = "{}/variants/haplotypecaller/{}.haplotypecaller-germline.vcf.gz".format(self.outdir, capture_str)
        haplotypecaller.jobname = "gatk-haplotypecaller-germline-{}".format(capture_str)

        self.add(haplotypecaller)


        strelka_germline = StrelkaGermline(input_bam=bam,
                          normal_id=capture_str,
                          reference_sequence=self.refdata['reference_genome'],
                          output_dir="{}/variants/{}-strelka-germline".format(self.outdir, capture_str),
                          target_bed=self.refdata['targets'][targets]['targets-bed-slopped20-gz'],
                          output_filtered_vcf="{}/variants/{capture_str}-strelka-germline/results/variants/{capture_str}.strelka.passed.vcf.gz".format(self.outdir, capture_str=capture_str)
                          )
        strelka_germline.jobname = "strelka-germline-workflow/{}".format(capture_str)

        self.add(strelka_germline)

        merge_germline_vcfs = MergeVCF() 
        merge_germline_vcfs.input_vcf_hc = haplotypecaller.output
        merge_germline_vcfs.input_vcf_strelka = strelka_germline.output_filtered_vcf
        merge_germline_vcfs.reference_genome = self.refdata['reference_genome']
        merge_germline_vcfs.output_vcf = "{}/variants/{}-all.germline.vcf.gz".format(self.outdir, capture_str)
        merge_germline_vcfs.jobname = "germline-vcf-merging/{}".format(capture_str)

        self.add(merge_germline_vcfs)

        vepped_vcf = None
        if self.vep_data_is_available():
            vep_germline_vcf = VEP()
            vep_germline_vcf.input_vcf = merge_germline_vcfs.output_vcf
            vep_germline_vcf.threads = self.maxcores
            vep_germline_vcf.reference_sequence = self.refdata['reference_genome']
            vep_germline_vcf.vep_dir = self.refdata['vep_dir']
            vep_germline_vcf.brca_exchange_vcf = self.refdata['brca_exchange']
            vep_germline_vcf.output_vcf = "{}/variants/{}.all.germline.vep.vcf".format(self.outdir, capture_str)
            vep_germline_vcf.jobname = "vep-merged-germline-vcf-{}".format(capture_str)
            self.add(vep_germline_vcf)
            vepped_vcf = vep_germline_vcf.output_vcf

        generate_igvnav_input = GenerateIGVNavInput()
        generate_igvnav_input.input_vcf = vep_germline_vcf.output_vcf
        generate_igvnav_input.oncokb_db = self.refdata['oncokb']
        generate_igvnav_input.vcftype = "germline"
        generate_igvnav_input.output = "{}/{}-igvnav-input.txt".format(self.outdir, capture_str)
        generate_igvnav_input.jobname = "IGVNavInput-file-generation-{}".format(capture_str) 

        self.add(generate_igvnav_input)

        self.set_germline_vcf(normal_capture, (merge_germline_vcfs.output_vcf, vepped_vcf))
            
    def configure_panel_analysis_with_normal(self, normal_capture):
        """
        Configure panel analyses focused on a specific unique normal library capture.
        """

        if normal_capture.sample_type != "N":
            raise ValueError("Invalid input capture: " + compose_sample_str(normal_capture))

        normal_bam = self.get_capture_bam(normal_capture, self.umi)
        # Configure germline variant calling:
        self.call_germline_variants(normal_capture, normal_bam)

        # For each unique cancer library capture, configure a comparative analysis against
        # this normal capture:
        for cancer_capture in self.get_mapped_captures_cancer():
            self.configure_panel_analysis_cancer_vs_normal(
                normal_capture, cancer_capture)

    def configure_make_cnvkit_tracks(self, unique_capture):
        input_cnr = self.capture_to_results[unique_capture].cnr
        input_cns = self.capture_to_results[unique_capture].cns

        sample_str = compose_lib_capture_str(unique_capture)

        if input_cnr:
            make_cnvkit_tracks = MakeCNVkitTracks()
            make_cnvkit_tracks.input_cnr = input_cnr
            make_cnvkit_tracks.input_cns = input_cns
            make_cnvkit_tracks.output_profile_bedgraph = "{}/cnv/{}_profile.bedGraph".format(
                self.outdir, sample_str)
            make_cnvkit_tracks.output_segments_bedgraph = "{}/cnv/{}_segments.bedGraph".format(
                self.outdir, sample_str)
            self.add(make_cnvkit_tracks)

    def configure_fix_cnvkit(self, unique_capture, cnr, cns, cnvkit_fix_filename):
        """
        Configure a job to fix the cnvkit output for the specified unique capture.

        :param unique_capture: Named tuple identifying a sample library capture.
        :param cnr: String indicating unfixed cnr file location
        :param cns: String indicating unfixed cns file location
        :param cnvkit_fix_filename: File containing table of data used to fix the outputs.
        """

        sample_str = compose_lib_capture_str(unique_capture)

        cnvkit_fix = CNVkitFix(input_cnr=cnr,
                               input_cns=cns,
                               input_ref=cnvkit_fix_filename,
                               output_cnr="{}/cnv/{}-fixed.cnr".format(self.outdir, sample_str),
                               output_cns="{}/cnv/{}-fixed.cns".format(self.outdir, sample_str))

        self.set_capture_cnr(unique_capture, cnvkit_fix.output_cnr)
        self.set_capture_cns(unique_capture, cnvkit_fix.output_cns)

        self.add(cnvkit_fix)

    def configure_single_capture_analysis(self, unique_capture):
        """
        Configure all general analyses to perform given a single sample library capture.
        In UMI pipeline, CNVkit should be analyzed with normal bam file
        """

        input_bam = self.get_capture_bam(unique_capture, umi=False)
        sample_str = compose_lib_capture_str(unique_capture)
        capture_kit_name = self.get_capture_name(unique_capture.capture_kit_id)
        library_kit_name = self.get_prep_kit_name(unique_capture.library_kit_id)
        sample_type = unique_capture.sample_type

        # Configure CNV kit analysis:
        cnvkit = CNVkit(input_bam=input_bam,
                        output_cnr="{}/cnv/{}.cnr".format(self.outdir, sample_str),
                        output_cns="{}/cnv/{}.cns".format(self.outdir, sample_str),
                        scratch=self.scratch)

        # FIXME: Improve this messy code for extracting the relevant cnvkit reference from self.refdata:
        cnvkit.reference = None
        if 'cnvkit-ref' in self.refdata['targets'][capture_kit_name]:
            # Retrieve the first (in arbitrary order) reference available for this capture kit,
            # as a fall-back:
            cnvkit.reference = self.refdata['targets'][capture_kit_name]['cnvkit-ref'].values()[0].values()[0]
        try:
            # Try to get a more specific reference, if it available:
            cnvkit.reference = self.refdata['targets'][capture_kit_name]['cnvkit-ref'][library_kit_name][sample_type]
        except KeyError:
            pass

        # if not cnvkit.reference:
        #     cnvkit.targets_bed = self.refdata['targets'][capture_kit_name]['targets-bed-slopped20']
        #     cnvkit.fasta = self.refdata["reference_genome"]
        if cnvkit.reference: 

            cnvkit.jobname = "cnvkit/{}".format(sample_str)

            # Register the result of this analysis:
            self.set_capture_cnr(unique_capture, cnvkit.output_cnr)
            self.set_capture_cns(unique_capture, cnvkit.output_cns)

            # FIXME: This extra step (fixing the cnv kit output) should perhaps go elsewhere.
            try:
                # Only fix the CNV-kit output if the required file is available:
                cnvkit_fix_filename = \
                    self.refdata['targets'][capture_kit_name]["cnvkit-fix"][library_kit_name][sample_type]
                self.configure_fix_cnvkit(unique_capture, cnvkit.output_cnr, cnvkit.output_cns, cnvkit_fix_filename)
            except KeyError:
                pass


            self.add(cnvkit)

            # Configure conversion of CNV kit output to seg format:
            seg_filename = "{}/cnv/{}.seg".format(
                self.outdir, sample_str)
            cns2seg = Cns2Seg(self.capture_to_results[unique_capture].cns, seg_filename)
            self.add(cns2seg)

            self.set_capture_seg(unique_capture, cns2seg.output_seg)

    def configure_lowpass_analyses(self):
        """
        Configure generic analyses of all low-pass whole-genome sequencing
        data for this clinseq pipeline, under the assumption that alignment and
        bam file merging has already been performed."""

        for unique_wgs in self.get_mapped_captures_only_wgs():
            self.configure_single_wgs_analyses(unique_wgs)

    def configure_make_qdnaseq_tracks(self, qdnaseq_output, sample_str):
        make_qdnaseq_tracks = MakeQDNAseqTracks()
        make_qdnaseq_tracks.input_qdnaseq_file = qdnaseq_output
        make_qdnaseq_tracks.output_segments_bedgraph = "{}/cnv/{}_qdnaseq_segments.bedGraph".format(
            self.outdir, sample_str)
        make_qdnaseq_tracks.output_copynumber_tdf = "{}/cnv/{}_qdnaseq_copynumber.tdf".format(
            self.outdir, sample_str)
        make_qdnaseq_tracks.output_readcount_tdf = "{}/cnv/{}_qdnaseq_readcount.tdf".format(
            self.outdir, sample_str)
        self.add(make_qdnaseq_tracks)

    def configure_single_wgs_analyses(self, unique_wgs):
        """
        Configure generic analyses of a single WGS item in the pipeline.

        :param unique_wgs: An identifier for a single unique library WGS.
        """

        input_bam = self.get_capture_bam(unique_wgs)
        sample_str = compose_lib_capture_str(unique_wgs)

        qdnaseq = QDNASeq(input_bam,
                          output_segments="{}/cnv/{}-qdnaseq.segments.txt".format(
                              self.outdir, sample_str),
                          background=None)

        self.configure_make_qdnaseq_tracks(qdnaseq.output, sample_str)

        self.add(qdnaseq)

    def run_wgs_bam_qc(self, bams):
        """
        Run QC on wgs bams
        :param bams: list of bams
        :return: list of generated files
        """
        qc_files = []
        logging.debug("bams are {}".format(bams))
        for bam in bams:
            basefn = stripsuffix(os.path.basename(bam), ".bam")
            isize = PicardCollectInsertSizeMetrics()
            isize.input = bam
            isize.jobname = "picard-isize-{}".format(basefn)
            isize.output_metrics = "{}/qc/picard/wgs/{}.picard-insertsize.txt".format(self.outdir, basefn)
            self.add(isize)

            wgsmetrics = PicardCollectWgsMetrics()
            wgsmetrics.input = bam
            wgsmetrics.reference_sequence = self.refdata['reference_genome']
            wgsmetrics.output_metrics = "{}/qc/picard/wgs/{}.picard-wgsmetrics.txt".format(self.outdir, basefn)
            wgsmetrics.jobname = "picard-wgsmetrics-{}".format(basefn)
            self.add(wgsmetrics)

            qc_files += [isize.output_metrics, wgsmetrics.output_metrics]

        return qc_files

    def configure_panel_analyses(self):
        """
        Configure generic analyses of all panel data for this clinseq pipeline,
        assuming that alignment and bam file merging has been performed.
        """

        # Configure analyses to be run on all unique panel captures individually:
        for unique_capture in self.get_mapped_captures_no_wgs():
            self.configure_single_capture_analysis(unique_capture)
            self.configure_make_cnvkit_tracks(unique_capture)

        # Configure a separate group of analyses for each unique normal library capture:
        for normal_capture in self.get_mapped_captures_normal():
            self.configure_panel_analysis_with_normal(normal_capture)

    def configure_panel_msings_analyses(self):
        """Configure msings analyses for all unique captures for which this is
        possible."""

        for unique_capture in self.get_mapped_captures_cancer():
            try:
                self.configure_msings(unique_capture)
            except InvalidRefDataException:
                # This indicates the reference data does not support configuring
                # msings for this cancer capture => Ignore this and proceed to the next:
                pass

    def configure_somatic_calling(self, normal_capture, cancer_capture):
        """
        Configure somatic variant calling in this pipeline, for a specified pairing
        of normal and cancer library capture events. 

        :param normal_capture: Named tuple indicating normal library capture.
        :param cancer_capture: Named tuple indicating cancer library capture.
        """

        cancer_bam = self.get_capture_bam(cancer_capture, self.umi)
        normal_bam = self.get_capture_bam(normal_capture, self.umi)
        target_name = self.get_capture_name(cancer_capture.capture_kit_id)

        # FIXME: Need to fix the configuration of the min_alt_frac threshold, rather than hard-coding it here:
        somatic_variants = call_somatic_variants(
            self, cancer_bam=cancer_bam, normal_bam=normal_bam,
            cancer_capture=cancer_capture, normal_capture=normal_capture,
            target_name=target_name,
            outdir=self.outdir, callers=['vardict','strelka','mutect2','varscan'],
            min_alt_frac=self.get_job_param('vardict-min-alt-frac'),
            min_num_reads=self.get_job_param('vardict-min-num-reads'))

        normal_capture_str = compose_lib_capture_str(normal_capture)
        cancer_capture_str = compose_lib_capture_str(cancer_capture)

        somatic_seq = SomaticSeq()
        somatic_seq.input_normal = normal_bam
        somatic_seq.input_tumor = cancer_bam
        somatic_seq.reference_sequence = self.refdata['reference_genome']
        somatic_seq.input_mutect_vcf = somatic_variants['mutect2']
        somatic_seq.input_varscan_snv = somatic_variants['varscan_snv']
        somatic_seq.input_varscan_indel = somatic_variants['varscan_indel'] 
        somatic_seq.input_vardict_vcf = somatic_variants['vardict']
        somatic_seq.input_strelka_snv = somatic_variants['strelka_snvs']
        somatic_seq.input_strelka_indel = somatic_variants['strelka_indels']
        somatic_seq.out_dir = "{}/variants/{}-{}-somatic-seq".format(self.outdir, normal_capture_str, cancer_capture_str)
        somatic_seq.out_snv = "{}/variants/{}-{}-somatic-seq/Consensus.sSNV.vcf".format(self.outdir, normal_capture_str, cancer_capture_str)
        somatic_seq.out_indel = "{}/variants/{}-{}-somatic-seq/Consensus.sINDEL.vcf".format(self.outdir, normal_capture_str, cancer_capture_str)
        somatic_seq.output_vcf = "{}/variants/{}-{}-all.somatic.vcf.gz".format(self.outdir, normal_capture_str, cancer_capture_str)
        self.add(somatic_seq)

        self.normal_cancer_pair_to_results[(normal_capture, cancer_capture)].somatic_vcf = \
            somatic_seq.output_vcf

    def configure_vep(self, normal_capture, cancer_capture):
        if not self.vep_data_is_available():
            raise ValueError("Invalid call to configure_vep: No vep data available.")

        somatic_vcf = self.normal_cancer_pair_to_results[(normal_capture, cancer_capture)].somatic_vcf

        cancer_capture_str = compose_lib_capture_str(cancer_capture)
        normal_capture_str = compose_lib_capture_str(normal_capture)

        vep = VEP()
        vep.input_vcf = somatic_vcf
        vep.threads = self.maxcores
        vep.reference_sequence = self.refdata['reference_genome']
        vep.vep_dir = self.refdata['vep_dir']
        vep.brca_exchange_vcf = self.refdata['brca_exchange']
        vep.output_vcf = "{}/variants/{}-{}.all.somatic.vep.vcf".format(
            self.outdir, normal_capture_str, cancer_capture_str)
        vep.jobname = "vep-merged-somatic-vcf/{}".format(cancer_capture_str)
        vep.additional_options = self.get_job_param("vep-additional-options")
        self.add(vep)
        self.normal_cancer_pair_to_results[(normal_capture, cancer_capture)].vepped_vcf = \
            vep.output_vcf

        generate_igvnav_input = GenerateIGVNavInput()
        generate_igvnav_input.input_vcf = vep.output_vcf
        generate_igvnav_input.oncokb_db = self.refdata['oncokb']
        generate_igvnav_input.vcftype = "somatic"
        generate_igvnav_input.output = "{}/{}-{}-igvnav-input.txt".format(self.outdir, normal_capture_str, cancer_capture_str)
        generate_igvnav_input.jobname = "IGVNavInput-file-generation-{}-{}".format(normal_capture_str, cancer_capture_str) 

        self.add(generate_igvnav_input)

    def configure_make_allelic_fraction_track(self, normal_capture, cancer_capture):
        """
        Configure a small job for converting the germline variant somatic allelic fraction
        information into tracks for displaying in IGV.

        :param normal_capture: Named tuple indicating normal library capture.
        :param cancer_capture: Named tuple indicating cancer library capture.
        """

        vcf = self.normal_cancer_pair_to_results[(normal_capture, cancer_capture)].vcf_addsample_output
        make_allelic_fraction_track = MakeAllelicFractionTrack()
        make_allelic_fraction_track.input_vcf = vcf
        normal_capture_str = compose_lib_capture_str(normal_capture)
        cancer_capture_str = compose_lib_capture_str(cancer_capture)
        make_allelic_fraction_track.output_bedgraph = \
            "{}/variants/{}-and-{}.germline-variants-somatic-afs.bedGraph".format(
            self.outdir, normal_capture_str, cancer_capture_str)
        self.add(make_allelic_fraction_track)

    def configure_vcf_add_sample(self, normal_capture, cancer_capture):
        """
        Configure VCF updating in this pipeline, for a specified pairing
        of normal and cancer library capture events. 

        :param normal_capture: Named tuple indicating normal library capture.
        :param cancer_capture: Named tuple indicating cancer library capture.
        """

        # Configure VCF add sample:
        vcfaddsample = VcfAddSample()
        vcfaddsample.input_bam = self.get_capture_bam(cancer_capture, self.umi)
        vcfaddsample.input_vcf = self.get_germline_vcf(normal_capture)
        normal_capture_str = compose_lib_capture_str(normal_capture)
        cancer_capture_str = compose_lib_capture_str(cancer_capture)
        cancer_sample_str = compose_sample_str(cancer_capture)
        vcfaddsample.samplename = cancer_sample_str
        vcfaddsample.filter_hom = True
        vcfaddsample.output = "{}/variants/{}-and-{}.germline-variants-with-somatic-afs.vcf.gz".format(
            self.outdir, normal_capture_str, cancer_capture_str)
        vcfaddsample.jobname = "vcf-add-sample-{}".format(cancer_capture_str)
        self.add(vcfaddsample)
        self.normal_cancer_pair_to_results[(normal_capture, cancer_capture)].vcf_addsample_output = \
            vcfaddsample.output

    def configure_msi_sensor(self, normal_capture, cancer_capture):
        """
        Configure MSI sensor in this pipeline, for a specified pairing
        of normal and cancer library capture events. 

        :param normal_capture: Named tuple indicating normal library capture.
        :param cancer_capture: Named tuple indicating cancer library capture.
        """

        # Configure MSI sensor:
        msisensor = MsiSensor()
        cancer_capture_name = self.get_capture_name(cancer_capture.capture_kit_id)
        msisensor.msi_sites = self.refdata['targets'][cancer_capture_name]['msisites']
        msisensor.input_normal_bam = self.get_capture_bam(normal_capture, umi=False)
        msisensor.input_tumor_bam = self.get_capture_bam(cancer_capture, umi=False)
        normal_capture_str = compose_lib_capture_str(normal_capture)
        cancer_capture_str = compose_lib_capture_str(cancer_capture)
        msisensor.output = "{}/msisensor-{}-{}.tsv".format(
            self.outdir, normal_capture_str, cancer_capture_str)
        msisensor.threads = self.maxcores
        msisensor.jobname = "msisensor-{}-{}".format(normal_capture_str, cancer_capture_str)
        self.normal_cancer_pair_to_results[(normal_capture, cancer_capture)].msi_output = \
            msisensor.output
        self.add(msisensor)

    def configure_msings(self, cancer_capture):
        """
        Configure msings analysis, which operates on a cancer capture bam
        input file.

        :param cancer_capture: Named tuple indicating cancer library capture.
        """

        # Configure Msings:
        msings = Msings()
        cancer_capture_name = self.get_capture_name(cancer_capture.capture_kit_id)
        msings.input_fasta = self.refdata['reference_genome']
        try:
            msings.msings_baseline = self.refdata['targets'][cancer_capture_name]['msings-baseline']
            msings.msings_bed = self.refdata['targets'][cancer_capture_name]['msings-bed']
            msings.msings_intervals = self.refdata['targets'][cancer_capture_name]['msings-msi_intervals']
        except KeyError:
            raise InvalidRefDataException("Missing msings data.")

        # FIXME: The above logic could be cleaned up.
        if not msings.msings_bed:
            raise InvalidRefDataException("Missing msings data.")

        msings.input_bam = self.get_capture_bam(cancer_capture, umi=False)
        cancer_capture_str = compose_lib_capture_str(cancer_capture)
        msings.outdir = "{}/msings-{}".format(
            self.outdir, cancer_capture_str)
        # FIXME: This is nasty:
        bam_name = os.path.splitext(os.path.basename(msings.input_bam))[0]
        msings.output = "{}/{}/{}.MSI_Analysis.txt".format(
            msings.outdir, bam_name, bam_name)
        msings.threads = self.maxcores
        msings.jobname = "msings-{}".format(cancer_capture_str)
        self.capture_to_results[cancer_capture].msings_output = msings.output
        self.add(msings)

    def configure_hz_conc(self, normal_capture, cancer_capture):
        """
        Configure heterozygote concordance calculation in this pipeline, for a
        specified pairing of normal and cancer library capture events. 

        :param normal_capture: Named tuple indicating normal library capture.
        :param cancer_capture: Named tuple indicating cancer library capture.
        """

        # Configure heterozygote concordance:
        hzconcordance = HeterzygoteConcordance()
        hzconcordance.input_vcf = self.get_germline_vcf(normal_capture)
        hzconcordance.input_bam = self.get_capture_bam(cancer_capture)
        hzconcordance.reference_sequence = self.refdata['reference_genome']
        cancer_capture_name = self.get_capture_name(cancer_capture.capture_kit_id)
        hzconcordance.target_regions = \
            self.refdata['targets'][cancer_capture_name]['targets-interval_list-slopped20']
        hzconcordance.normalid = compose_sample_str(normal_capture)
        hzconcordance.filter_reads_with_N_cigar = True
        hzconcordance.jobname = "hzconcordance-{}".format(compose_lib_capture_str(cancer_capture))
        hzconcordance.output = "{}/bams/{}-{}-hzconcordance.txt".format(
            self.outdir, compose_lib_capture_str(cancer_capture), compose_lib_capture_str(normal_capture))
        self.normal_cancer_pair_to_results[(normal_capture, cancer_capture)].hzconcordance_output = \
            hzconcordance.output
        self.add(hzconcordance)

    def configure_contest_vcf_generation(self, normal_capture, cancer_capture):
        """
        Configure generation of a contest VCF input file in this pipeline, for a
        specified pairing of normal and cancer library capture events. 

        :param normal_capture: Named tuple indicating normal library capture.
        :param cancer_capture: Named tuple indicating cancer library capture.
        """

        contest_vcf_generation = CreateContestVCFs()
        normal_capture_name = self.get_capture_name(normal_capture.capture_kit_id)
        cancer_capture_name = self.get_capture_name(cancer_capture.capture_kit_id)
        normal_targets = self.refdata['targets'][normal_capture_name]['targets-bed-slopped20']
        cancer_targets = self.refdata['targets'][cancer_capture_name]['targets-bed-slopped20']
        contest_vcf_generation.input_target_regions_bed_1 = normal_targets
        contest_vcf_generation.input_target_regions_bed_2 = cancer_targets
        contest_vcf_generation.input_population_vcf = self.refdata["swegene_common"]
        normal_capture_str = compose_lib_capture_str(normal_capture)
        cancer_capture_str = compose_lib_capture_str(cancer_capture)
        contest_vcf_generation.output = "{}/contamination/pop_vcf_{}-{}.vcf".format(
            self.outdir, normal_capture_str, cancer_capture_str)
        contest_vcf_generation.jobname = "contest_pop_vcf_{}-{}".format(
            normal_capture_str, cancer_capture_str)
        self.add(contest_vcf_generation)
        return contest_vcf_generation.output

    def configure_contest(self, library_capture_1, library_capture_2, contest_vcf):
        """
        Configure running of ContEst in this pipeline, for a specified pairing
        of library capture events. Estimates contamination in the bam file for the
        first library capture, using the bam file for the second library capture as
        a reference comparison.

        :param library_capture_1: Named tuple indicating first library capture.
        :param library_capture_2: Named tuple indicating second library capture.
        :param contest_vcf: Contest population allele frequency VCF input file.
        """

        contest = ContEst()
        contest.reference_genome = self.refdata['reference_genome']
        contest.input_eval_bam = self.get_capture_bam(library_capture_1, umi=False)
        contest.input_genotype_bam = self.get_capture_bam(library_capture_2, umi=False)
        contest.input_population_af_vcf = contest_vcf
        # TODO: Is it necessary to create the output subdir contamination somewhere? Check how it's done for e.g. cnvkit.
        contest.output = "{}/contamination/{}.contest.txt".format(self.outdir, compose_lib_capture_str(library_capture_1)) # TODO: Should the analysis id also be in name of out file?
        contest.jobname = "contest_tumor/{}".format(compose_lib_capture_str(library_capture_1))  # TODO: Is it ok that the job name does not contain analysis id, i.e. may not be unique?
        self.add(contest)
        return contest.output

    def configure_contam_qc_call(self, contest_output, library_capture):
        """
        Configure generation of a contamination QC call in this pipeline,
        based on the specified contest output. Returns the resulting QC output
        filename.

        :param contest_output: ContEst output filename.
        :param library_capture: Named tuple identifying a unique library capture.
        """

        process_contest = ContEstToContamCaveat()
        process_contest.input_contest_results = contest_output
        process_contest.output = "{}/qc/{}-contam-qc-call.json".format(
            self.outdir, compose_lib_capture_str(library_capture))
        self.add(process_contest)
        return process_contest.output

    def configure_contamination_estimate(self, normal_capture, cancer_capture):
        """
        Configure contamination estimatates for a given normal, cancer library capture
        pairing.

        :param normal_capture: Namedtuple indicating a normal library capture.
        :param cancer_capture: Namedtuple indicating a cancer library capture. 
        """
        # Configure generation of the contest VCF input file:
        intersection_contest_vcf = \
            self.configure_contest_vcf_generation(normal_capture, cancer_capture)

        # Configure contest for calculating contamination in the cancer sample:
        cancer_vs_normal_contest_output = \
            self.configure_contest(cancer_capture, normal_capture, intersection_contest_vcf)

        # Configure contest for calculating contamination in the normal sample:
        normal_vs_cancer_contest_output = \
            self.configure_contest(normal_capture, cancer_capture, intersection_contest_vcf)

        # Configure cancer sample contamination QC call:
        cancer_contam_call = self.configure_contam_qc_call(cancer_vs_normal_contest_output,
                                                           cancer_capture)

        # Register the outputs of running contest:
        self.normal_cancer_pair_to_results[(normal_capture, cancer_capture)].normal_contest_output = \
            normal_vs_cancer_contest_output
        self.normal_cancer_pair_to_results[(normal_capture, cancer_capture)].cancer_contest_output = \
            cancer_vs_normal_contest_output
        self.normal_cancer_pair_to_results[(normal_capture, cancer_capture)].cancer_contam_call = \
            cancer_contam_call

    def configure_purecn(self, normal_capture, cancer_capture, umi):
        """
        Configure PureCN, and also configure the custom run of VarDict, which is
        required for PureCN.

        :param normal_capture: A unique normal sample library capture
        :param cancer_capture: A unique cancer sample library capture
        """

        cancer_bam = self.get_capture_bam(cancer_capture, umi=umi)
        normal_bam = self.get_capture_bam(normal_capture, umi=umi)
        target_name = self.get_capture_name(cancer_capture.capture_kit_id)

        cancer_capture_str = compose_lib_capture_str(cancer_capture)
        capture_name = self.get_capture_name(cancer_capture.capture_kit_id)
        normal_capture_str = compose_lib_capture_str(normal_capture)
        
        # hard coded min AF and error rate, depending on UMI, for now
        if umi:
            minaf = 0.01
            error = 0.0005
        else:
            minaf = 0.02
            error = 0.001

        # Configure the PureCN-specific VarDict job:
        vardict_pureCN = VarDictForPureCN()
        vardict_pureCN.input_tumor = cancer_bam
        vardict_pureCN.input_normal = normal_bam
        vardict_pureCN.tumorid = cancer_capture_str
        vardict_pureCN.normalid = normal_capture_str
        vardict_pureCN.reference_sequence = self.refdata['reference_genome']
        vardict_pureCN.reference_dict = self.refdata['reference_dict']
        vardict_pureCN.target_bed = self.refdata['targets'][target_name]['targets-bed-slopped20']
        vardict_pureCN.dbsnp = self.refdata["dbSNP"]
        vardict_pureCN.min_alt_frac = minaf
        vardict_pureCN.min_num_reads = 6  # hard coded number of reads
        vardict_pureCN.output = "{}/variants/{}-{}.vardict-somatic-purecn.vcf.gz".format(
            self.outdir, cancer_capture_str, normal_capture_str)
        vardict_pureCN.jobname = "vardict_purecn/{}-{}".format(cancer_capture_str, normal_capture_str)
        self.add(vardict_pureCN)

        # Retrieve the relevant seg-format file:
        seg_filename = self.capture_to_results[cancer_capture].seg
        cnr_filename = self.capture_to_results[cancer_capture].cnr

        # Configure PureCN itself:
        
        # FIXME: NOTE: The Job params *must* be specified as arguments in the case of PureCN:
        pureCN = PureCN(
            input_seg=seg_filename,
            input_cnr=cnr_filename,
            input_vcf=vardict_pureCN.output,
            tumorid=cancer_capture_str,
            outdir="{}/purecn".format(self.outdir),
            postopt=True,
            minaf=minaf,
            error=error,
            maxnonclonal=self.get_job_param("maxnonclonal_purecn")
        )
        self.add(pureCN)

        # FIXME: It seems like a nasty hack to include a dictionary here, perhaps this belongs elsewhere?
        self.normal_cancer_pair_to_results[(normal_capture, cancer_capture)].pureCN_outputs = {
            "csv": "{}/{}.csv".format(pureCN.outdir, pureCN.tumorid),
            "genes_csv": "{}/{}_genes.csv".format(pureCN.outdir, pureCN.tumorid),
            "loh_csv": "{}/{}_loh.csv".format(pureCN.outdir, pureCN.tumorid),
            "variants_csv": "{}/{}_variants.csv".format(pureCN.outdir, pureCN.tumorid),
        }

    def configure_panel_analysis_cancer_vs_normal(self, normal_capture, cancer_capture):
        """
        Configures standard paired cancer vs normal panel analyses for the specified unique
        normal and cancer library captures.

        Comprises the following analyses:
        - Somatic variant calling
        - Running VEP on the resulting somatic VCF
        - Updating of the germline VCF to take into consideration the cancer sample
        - MSI sensor
        - Heterozygote concordance of the sample pair
        - Contamination estimate of cancer compared with normal and vice versa

        :param normal_capture: A unique normal sample library capture
        :param cancer_capture: A unique cancer sample library capture
        """

        self.configure_somatic_calling(normal_capture, cancer_capture)
        if self.vep_data_is_available():
            self.configure_vep(normal_capture, cancer_capture)
        self.configure_vcf_add_sample(normal_capture, cancer_capture)
        self.configure_make_allelic_fraction_track(normal_capture, cancer_capture)
        self.configure_msi_sensor(normal_capture, cancer_capture)
        #self.configure_hz_conc(normal_capture, cancer_capture)
        self.configure_contamination_estimate(normal_capture, cancer_capture)

    def configure_all_lowpass_qcs(self):
        """
        Configure QC checks for all low-pass whole genome data in this pipeline.
        """

        for unique_wgs in self.get_mapped_captures_only_wgs():
            self.qc_files += \
                self.configure_wgs_qc(unique_wgs)

    def configure_wgs_qc(self, unique_wgs):
        """
        Configure QC checks for the specified unique WGS item in this pipeline.

        :param unique_wgs: A named tuple identifying a single unique WGS item.
        :return: QC files output files resulting from the QC analysis configuration.
        """

        bam = self.get_capture_bam(unique_wgs)
        wgs_name = compose_lib_capture_str(unique_wgs)

        qc_files = []

        isize = PicardCollectInsertSizeMetrics()
        isize.input = bam
        isize.jobname = "picard-isize-{}".format(wgs_name)
        isize.output_metrics = "{}/qc/picard/wgs/{}.picard-insertsize.txt".format(self.outdir, wgs_name)
        self.add(isize)

        wgsmetrics = PicardCollectWgsMetrics()
        wgsmetrics.input = bam
        wgsmetrics.reference_sequence = self.refdata['reference_genome']
        wgsmetrics.output_metrics = "{}/qc/picard/wgs/{}.picard-wgsmetrics.txt".format(self.outdir, wgs_name)
        wgsmetrics.jobname = "picard-wgsmetrics-{}".format(wgs_name)
        self.add(wgsmetrics)

        qc_files += [isize.output_metrics, wgsmetrics.output_metrics]

        return qc_files

    def configure_all_panel_qcs(self):
        """
        Configures QC checks for all panel data (not including WGS data) in this pipeline.
        """

        for unique_capture in self.get_mapped_captures_no_wgs():
            self.qc_files += \
                self.configure_panel_qc(unique_capture)

    def configure_multi_qc(self):
        """
        Configures MultiQC for this pipeline. self.qc_files must be fully populated
        in order for MultiQC to use all relevant input files.
        """

        multiqc = MultiQC()
        multiqc.input_files = self.qc_files
        multiqc.search_dir = self.outdir
        multiqc.output = "{}/multiqc/{}-multiqc".format(self.outdir, self.analysis_id)
        multiqc.jobname = "multiqc-{}".format(self.sampledata['sdid'])
        self.add(multiqc)

    def get_coverage_bed(self, targets):
        """
        Retrieve the targets bed file to use for calculating coverage, given the specified
        targets name.

        :param targets: Target capture name
        :return: bed file name
        """
        return self.refdata['targets'][targets]['targets-bed-slopped20']

    def configure_panel_qc(self, unique_capture):
        """
        Configure QC analyses for a given library capture.

        :param unique_capture: Named tuple identifying a sample library capture.
        :return: list of QC output files for this capture.
        """

        bam = self.get_capture_bam(unique_capture, umi=False)

        targets = self.get_capture_name(unique_capture.capture_kit_id)
        logging.debug("Adding QC jobs for {}".format(bam))

        capture_str = compose_lib_capture_str(unique_capture)

        isize = PicardCollectInsertSizeMetrics()
        isize.input = bam
        isize.output_metrics = "{}/qc/picard/{}/{}.picard-insertsize.txt".format(
            self.outdir, unique_capture.capture_kit_id, capture_str)
        isize.jobname = "picard-isize-{}".format(capture_str)
        self.add(isize)

        oxog = PicardCollectOxoGMetrics()
        oxog.input = bam
        oxog.reference_sequence = self.refdata['reference_genome']
        oxog.output_metrics = "{}/qc/picard/{}/{}.picard-oxog.txt".format(
            self.outdir, unique_capture.capture_kit_id, capture_str)
        oxog.jobname = "picard-oxog-{}".format(capture_str)
        self.add(oxog)

        hsmetrics = PicardCollectHsMetrics()
        hsmetrics.input = bam
        hsmetrics.reference_sequence = self.refdata['reference_genome']
        hsmetrics.target_regions = self.refdata['targets'][targets][
            'targets-interval_list-slopped20']
        hsmetrics.bait_regions = self.refdata['targets'][targets][
            'targets-interval_list-slopped20']
        hsmetrics.bait_name = targets
        hsmetrics.output_metrics = "{}/qc/picard/{}/{}.picard-hsmetrics.txt".format(
            self.outdir, unique_capture.capture_kit_id, capture_str)
        hsmetrics.jobname = "picard-hsmetrics-{}".format(capture_str)
        self.add(hsmetrics)

        sambamba = SambambaDepth()
        sambamba.targets_bed = self.refdata['targets'][targets]['targets-bed-slopped20']
        sambamba.input = bam
        sambamba.output = "{}/qc/sambamba/{}.sambamba-depth-targets.txt".format(
            self.outdir, capture_str)
        sambamba.jobname = "sambamba-depth-{}".format(capture_str)
        self.add(sambamba)

        coverage_hist = CoverageHistogram()
        # FIXME: Ugly temporary solution to allow the alascca pipeline to use a specific
        # targets file:
        coverage_hist.input_bed = self.get_coverage_bed(targets)
        coverage_hist.input_bam = bam
        coverage_hist.output = "{}/qc/{}.coverage-histogram.txt".format(
            self.outdir, capture_str)
        coverage_hist.jobname = "alascca-coverage-hist/{}".format(capture_str)
        self.add(coverage_hist)

        coverage_qc_call = CoverageCaveat()
        coverage_qc_call.low_thresh_fraction = self.get_job_param('cov-low-thresh-fraction')
        coverage_qc_call.low_thresh_fold_cov = self.get_job_param('cov-low-thresh-fold-cov')
        coverage_qc_call.input_histogram = coverage_hist.output
        coverage_qc_call.output = "{}/qc/{}.coverage-qc-call.json".format(self.outdir, capture_str)
        coverage_qc_call.jobname = "coverage-qc-call/{}".format(capture_str)
        self.add(coverage_qc_call)
        self.capture_to_results[unique_capture].cov_qc_call = coverage_qc_call.output

        return [isize.output_metrics, oxog.output_metrics, hsmetrics.output_metrics,
                sambamba.output, coverage_hist.output, coverage_qc_call.output]
